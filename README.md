# Spring Boot Testing From Zero To Hero

스프링 부트에서 테스트 코드를 처음부터 고급까지 다루는 종합 가이드입니다.

## 소개

많은 좋은 개발자분들께서 이미 테스트의 중요성과 작성 방법에 대해 잘 정리하고 공유하고 있습니다. 이러한 자료들을 참고하여 TDD(Test-Driven Development), BDD(Behavior-Driven Development) 방식으로 개발을 진행하기도 하지만, **기존 코드베이스에 테스트 코드를 작성할 때**는 여전히 많은 고민이 따릅니다.

**산군 개발팀**에서는 테스트 코드를 작성할 시 개발자들이 동일한 수준의 이해도를 가지고 있음에도 불구하고, **테스트의 깊이**나 **테스트의 방향**이 서로 다른 경우가 종종 발생합니다. 이러한 상황을 개선하고, 더 안정적인 개발 프로세스를 구축하고자 **어느 정도의 규칙을 정하고**, 개발팀이 **같은 생각을 하며 같은 방향을 보며 개발**할 수 있도록 이 레포지토리를 만들게 되었습니다. 또한 **신규 백엔드 개발자의 온보딩**을 지원하기 위한 자료로도 활용하고자 합니다.

특히, **최적의 효율을 내는 테스트 방향 및 뎁스를 정하기 위해**, 이 레포지토리는 다음의 네 가지 핵심 질문에 대한 고민을 하고자 합니다.

1. **WHY** - 왜 테스트를 작성해야 하는가?
2. **HOW** - 테스트 코드를 어떻게 작성해야 하는가?
3. **WHEN** - 언제 테스트 코드를 적용해야 하는가?
4. **HOW MUCH** - 얼마나 깊게 테스트 코드를 작성해야 하는가?

간단한 **전자상거래(E-commerce) 시스템**을 예제로 삼아, 다양한 테스트 케이스와 실용적인 예제 코드를 통해 위의 핵심 질문에 대한 답을 찾아보고자 합니다.

## 목차

1. **WHY - 왜 테스트를 작성해야 하는가?**
    - 1.1 테스트 코드의 중요성
    - 1.2 테스트 코드 작성의 장점
        - 1.2.1 안정적인 개발 환경 구축
        - 1.2.2 버그 감소 및 코드 품질 향상
        - 1.2.3 리팩토링의 용이성
        - 1.2.4 단일 책임 원칙(SOLID) 준수
    - 1.3 테스트를 작성하지 않았을 때의 문제점
    - 1.4 카오스 엔지니어링의 필요성

2. **HOW - 테스트 코드를 어떻게 작성해야 하는가?**
    - 2.1 좋은 테스트 코드의 특징 (FIRST 원칙)
        - 2.1.1 Fast: 빠르게 실행되어야 함
        - 2.1.2 Isolated: 독립적으로 실행될 수 있어야 함
        - 2.1.3 Repeatable: 반복 실행 시 동일한 결과를 가져야 함
        - 2.1.4 Self-Validating: 스스로 결과를 검증할 수 있어야 함
        - 2.1.5 Timely: 적시에 작성되어야 함
    - 2.2 테스트 케이스 선택 방법
        - 2.2.1 첫 번째 테스트의 중요성
        - 2.2.2 쉬운 케이스부터 시작하여 점진적으로 확장
    - 2.3 TDD(Test-Driven Development) 방법론
        - 2.3.1 레드 단계: 실패하는 테스트 작성
        - 2.3.2 그린 단계: 최소한의 코드로 테스트 통과
        - 2.3.3 리팩터 단계: 코드 개선 및 중복 제거
        - 2.3.4 레드-그린-리팩터 사이클 반복
    - 2.4 다양한 테스트 종류와 계층 구조 이해
        - 2.4.1 단위 테스트
        - 2.4.2 통합 테스트
        - 2.4.3 시스템 테스트 등
    - 2.5 JUnit5 활용
        - 2.5.1 JUnit의 구성 요소 및 특징
        - 2.5.2 주요 어노테이션 (@Test, @BeforeAll 등)
        - 2.5.3 어서션 메서드 (assertEquals, assertNull 등)
    - 2.6 Mockito와 같은 Mocking 프레임워크 사용
        - 2.6.1 테스트 더블(Test Doubles)의 종류와 활용
            - 2.6.1.1 Dummy
            - 2.6.1.2 Stub
            - 2.6.1.3 Mock
            - 2.6.1.4 Spy
            - 2.6.1.5 Fake
        - 2.6.2 Mockito를 활용한 Mock 객체 생성 및 사용 방법
    - 2.7 다양한 테스트 어노테이션 및 도구 활용
        - 2.7.1 Parameterized Tests: @ParameterizedTest
            - 2.7.1.1 @ValueSource, @EnumSource, @MethodSource 등
        - 2.7.2 Nested Tests: @Nested
        - 2.7.3 Display Names: @DisplayName 및 @DisplayNameGeneration
        - 2.7.4 Assumptions: assumeTrue, assumeFalse 등
        - 2.7.5 Timeout: @Timeout을 활용한 시간 제한 테스트
        - 2.7.6 Repeated Tests: @RepeatedTest
        - 2.7.7 Spring Boot Test 어노테이션
            - 2.7.7.1 @SpringBootTest
            - 2.7.7.2 @WebMvcTest
            - 2.7.7.3 @DataJpaTest
            - 2.7.7.4 @RestClientTest
        - 2.7.8 Testcontainers를 활용한 통합 테스트
        - 2.7.9 MockMvc와 WebTestClient를 사용한 웹 레이어 테스트
        - 2.7.10 Hamcrest와 AssertJ를 활용한 어서션 강화
        - 2.7.11 ArchUnit: 아키텍처 규칙 검증
        - 2.7.12 JsonPath: JSON 결과 검증
        - 2.7.13 @Sql 어노테이션: 테스트용 데이터베이스 초기화

3. **WHEN - 언제 테스트 코드를 적용해야 하는가?**
    - 3.1 TDD와 BDD의 개념 및 적용 시점
    - 3.2 기존 코드베이스에 테스트 추가하기
        - 3.2.1 레거시 코드에 대한 테스트 작성 전략
        - 3.2.2 테스트 작성의 우선순위 설정
    - 3.3 새로운 기능 개발 시 테스트 작성 시점
        - 3.3.1 프로덕션 코드 작성 전에 테스트 코드 작성
        - 3.3.2 테스트 코드 기반의 개발 흐름 구축
    - 3.4 리팩토링 시 테스트의 역할
        - 3.4.1 기존 기능의 안정성 확보
        - 3.4.2 리팩토링 후 테스트를 통한 검증

4. **HOW DEEP - 얼마나 깊게 테스트 코드를 작성해야 하는가?**
    - 4.1 테스트 깊이를 결정하는 기준
        - 4.1.1 테스트 피라미드(Test Pyramid) 활용
            - 4.1.1.1 단위 테스트, 통합 테스트, E2E 테스트의 비율과 깊이
        - 4.1.2 위험 기반 테스트(Risk-Based Testing)
            - 4.1.2.1 비즈니스 중요도와 위험 요소에 따른 테스트 우선순위
        - 4.1.3 사용자 시나리오 및 유스 케이스 기반 테스트
            - 4.1.3.1 핵심 사용자 흐름과 엣지 케이스 식별
        - 4.1.4 현실적인 제약 조건과 팀 역량 고려
            - 4.1.4.1 시간과 자원 한계 인식
            - 4.1.4.2 팀의 경험 수준 반영
    - 4.2 테스트 커버리지 및 품질 지표 활용
        - 4.2.1 코드 커버리지의 의미와 한계
        - 4.2.2 효율적인 커버리지 목표 설정
    - 4.3 오버테스팅의 문제점
        - 4.3.1 유지보수 비용 증가
        - 4.3.2 개발 속도 저하
        - 4.3.3 과도한 테스트로 인한 리소스 낭비
    - 4.4 효율적인 테스트 범위 설정을 위한 체크리스트
        - 4.4.1 핵심 로직에 대한 집중적인 테스트
            - 4.4.1.1 주요 비즈니스 로직 검증
            - 4.4.1.2 경계 값 및 예외 상황 테스트
        - 4.4.2 주요 기능 및 사용자 시나리오 검증
            - 4.4.2.1 핵심 사용자 흐름 테스트
            - 4.4.2.2 다양한 사용자 역할 및 권한에 따른 테스트
        - 4.4.3 에러 및 예외 처리에 대한 테스트
            - 4.4.3.1 오류 메시지 및 예외 처리 검증
            - 4.4.3.2 인증 및 권한 부여 로직 테스트
        - 4.4.4 외부 시스템 및 통합 부분 테스트
            - 4.4.4.1 API 연동 및 응답 처리 검증
            - 4.4.4.2 데이터베이스 트랜잭션 일관성 확인
    - 4.5 리팩토링과 테스트의 균형 잡기
        - 4.5.1 필요한 부분에 집중하여 테스트 작성
        - 4.5.2 불필요하거나 중복된 테스트 코드 제거
        - 4.5.3 테스트 코드의 유지보수성과 가독성 확보

